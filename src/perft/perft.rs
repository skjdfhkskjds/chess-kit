use crate::board::Board;
use crate::movegen::MoveGenerator;
use crate::perft::{Depth, NodeCount, PerftData};
use crate::primitives::{Move, MoveList, MoveType};
use crate::transposition::TranspositionTable;

// perft calculates the number of leaf nodes at the given depth from the current
// position
//
// @param: board - mutable reference to the board
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: number of leaf nodes at the given depth
pub fn perft(
    board: &mut Board,
    move_generator: &MoveGenerator,
    tt: &mut TranspositionTable<PerftData>,
    depth: Depth,
) -> NodeCount {
    // base case: if the depth is 0, return 1
    if depth == 0 {
        return 1;
    }

    // check if we have a cached result in the transposition table
    if let Some(data) = tt.probe(board.state.zobrist_key)
        && data.depth() == depth
    {
        return data.node_count();
    }

    // get all the possible moves from the current position
    let mut moves = MoveList::new();
    move_generator.generate_moves(board, &mut moves, MoveType::All);

    // count the number of nodes at each branch of the move list
    let mut nodes = 0;
    for mv in moves.iter() {
        // make the move
        board.make_move(mv);

        // check if the move leaves the king in check
        //
        // Note: we check if the opponent is checked since `make_move` swaps the
        //       side to move.
        if !move_generator.is_checked(board, board.opponent()) {
            nodes += perft(board, move_generator, tt, depth - 1);
        }

        // undo the move
        board.unmake_move();
    }

    // cache the result in the transposition table
    tt.insert(board.state.zobrist_key, PerftData::new(depth, nodes));

    nodes
}

// perft_divide separates the perft calculation into a vector of branches of
// moves from the current position
//
// @param: board - mutable reference to the board
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: vector of branches of moves from the current position
fn perft_divide(
    board: &mut Board,
    move_generator: &MoveGenerator,
    tt: &mut TranspositionTable<PerftData>,
    depth: Depth,
) -> Vec<(Move, NodeCount)> {
    assert!(depth > 0);

    // generate all moves for the current position
    let mut moves = MoveList::new();
    move_generator.generate_moves(board, &mut moves, MoveType::All);

    // get the number of nodes generated by each move
    let mut branches = Vec::with_capacity(moves.len());
    for mv in moves.iter() {
        // make the move
        board.make_move(mv);

        // check if the move leaves the king in check
        //
        // Note: we check if the opponent is checked since `make_move` swaps the
        //       side to move.
        if !move_generator.is_checked(board, board.opponent()) {
            // push the number of nodes generated by this branch to the result
            branches.push((mv, perft(board, move_generator, tt, depth - 1)));
        }

        // undo the move
        board.unmake_move();
    }

    branches
}

// perft_divide_print executes `perft_divide` and prints the result
//
// @param: board - mutable reference to the board
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: number of leaf nodes at the given depth
pub fn perft_divide_print(
    board: &mut Board,
    move_generator: &MoveGenerator,
    tt: &mut TranspositionTable<PerftData>,
    depth: Depth,
) -> NodeCount {
    let entries = perft_divide(board, move_generator, tt, depth);

    let mut total = 0;
    for (mv, nodes) in entries {
        println!("{}: {}", mv, nodes);
        total += nodes;
    }

    println!("Total: {total}");
    total
}
