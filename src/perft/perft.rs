use crate::attack_table::AttackTable;
use crate::movegen::MoveGenerator;
use crate::perft::{Depth, NodeCount, PerftData};
use crate::position::Position;
use crate::primitives::{Black, Move, MoveList, MoveType, Sides, State, White};
use crate::transposition::TranspositionTable;

// perft calculates the number of leaf nodes at the given depth from the current
// position
//
// @param: position - mutable reference to the position
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: number of leaf nodes at the given depth
pub fn perft<A: AttackTable, S: State>(
    position: &mut Position<S>,
    move_generator: &MoveGenerator<A>,
    tt: &mut impl TranspositionTable<PerftData>,
    depth: Depth,
) -> NodeCount {
    // base case: if the depth is 0, return 1
    if depth == 0 {
        return 1;
    }

    // check if we have a cached result in the transposition table
    if let Some(data) = tt.probe(position.state.key())
        && data.depth() == depth
    {
        return data.node_count();
    }

    // get all the possible moves from the current position
    let mut moves = MoveList::new();
    move_generator.generate_moves(position, &mut moves, MoveType::All);

    // count the number of nodes at each branch of the move list
    let mut nodes = 0;
    for mv in moves.iter() {
        // make the move
        position.make_move(mv);

        // check if the move leaves the king in check, if it is, skip it
        //
        // Note: we check if the opponent is checked since `make_move` swaps the
        //       side to move.
        let is_checked = match position.turn() {
            Sides::White => move_generator.attack_table.is_checked::<Black, S>(position),
            Sides::Black => move_generator.attack_table.is_checked::<White, S>(position),
        };
        if !is_checked {
            nodes += perft(position, move_generator, tt, depth - 1);
        }

        // undo the move
        position.unmake_move();
    }

    // cache the result in the transposition table
    tt.insert(position.state.key(), PerftData::new(depth, nodes));

    nodes
}

// perft_divide separates the perft calculation into a vector of branches of
// moves from the current position
//
// @param: position - mutable reference to the position
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: vector of branches of moves from the current position
fn perft_divide<A: AttackTable, S: State>(
    position: &mut Position<S>,
    move_generator: &MoveGenerator<A>,
    tt: &mut impl TranspositionTable<PerftData>,
    depth: Depth,
) -> Vec<(Move, NodeCount)> {
    assert!(depth > 0);

    // generate all moves for the current position
    let mut moves = MoveList::new();
    move_generator.generate_moves(position, &mut moves, MoveType::All);

    // get the number of nodes generated by each move
    let mut branches = Vec::with_capacity(moves.len());
    for mv in moves.iter() {
        // make the move
        position.make_move(mv);

        // check if the move leaves the king in check, if it is, skip it
        //
        // Note: we check if the opponent is checked since `make_move` swaps the
        //       side to move.
        let is_checked = match position.turn() {
            Sides::White => move_generator.attack_table.is_checked::<Black, S>(position),
            Sides::Black => move_generator.attack_table.is_checked::<White, S>(position),
        };
        if !is_checked {
            // push the number of nodes generated by this branch to the result
            branches.push((mv, perft(position, move_generator, tt, depth - 1)));
        }

        // undo the move
        position.unmake_move();
    }

    branches
}

// perft_divide_print executes `perft_divide` and prints the result
//
// @param: position - mutable reference to the position
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: number of leaf nodes at the given depth
pub fn perft_divide_print<A: AttackTable, S: State>(
    position: &mut Position<S>,
    move_generator: &MoveGenerator<A>,
    tt: &mut impl TranspositionTable<PerftData>,
    depth: Depth,
) -> NodeCount {
    let entries = perft_divide(position, move_generator, tt, depth);

    let mut total = 0;
    for (mv, nodes) in entries {
        println!("{}: {}", mv, nodes);
        total += nodes;
    }

    println!("Total: {total}");
    total
}
