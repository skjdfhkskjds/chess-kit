use crate::movegen::MoveGenerator;
use crate::perft::{Depth, NodeCount, PerftData};
use crate::position::{PositionAttacks, PositionMoves, PositionState};
use crate::primitives::{Move, MoveList};
use crate::transposition::TranspositionTable;

// perft calculates the number of leaf nodes at the given depth from the current
// position
//
// @param: position - mutable reference to the position
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: number of leaf nodes at the given depth
pub fn perft<MoveGeneratorT, PositionT>(
    position: &mut PositionT,
    move_generator: &MoveGeneratorT,
    tt: &mut impl TranspositionTable<PerftData>,
    depth: Depth,
) -> NodeCount
where
    MoveGeneratorT: MoveGenerator,
    PositionT: PositionState + PositionAttacks + PositionMoves,
{
    // base case: if the depth is 0, return 1
    if depth == 0 {
        return 1;
    }

    // check if we have a cached result in the transposition table
    if let Some(data) = tt.probe(position.key())
        && data.depth() == depth
    {
        return data.node_count();
    }

    // get all the possible moves from the current position
    let mut moves = MoveList::new();
    move_generator.generate_legal_moves(position, &mut moves);

    // count the number of nodes at each branch of the move list
    let mut nodes = 0;
    for mv in moves.iter() {
        // just count leaf nodes instead of diving deeper
        if depth == 1 {
            nodes += 1;
            continue;
        }

        // make the move
        position.make_move(mv);

        // count the number of nodes recursively at the next depth
        nodes += perft(position, move_generator, tt, depth - 1);

        // undo the move
        position.unmake_move(mv);
    }

    // cache the result in the transposition table
    tt.insert(position.key(), PerftData::new(depth, nodes));

    nodes
}

// perft_divide separates the perft calculation into a vector of branches of
// moves from the current position
//
// @param: position - mutable reference to the position
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: vector of branches of moves from the current position
fn perft_divide<MoveGeneratorT, PositionT>(
    position: &mut PositionT,
    move_generator: &MoveGeneratorT,
    tt: &mut impl TranspositionTable<PerftData>,
    depth: Depth,
) -> Vec<(Move, NodeCount)>
where
    MoveGeneratorT: MoveGenerator,
    PositionT: PositionState + PositionAttacks + PositionMoves,
{
    assert!(depth > 0);

    // generate all moves for the current position
    let mut moves = MoveList::new();
    move_generator.generate_legal_moves(position, &mut moves);

    // get the number of nodes generated by each move
    let mut branches = Vec::with_capacity(moves.len());
    for mv in moves.iter() {
        // make the move
        position.make_move(mv);

        // push the number of nodes generated by this branch to the result
        branches.push((mv, perft(position, move_generator, tt, depth - 1)));

        // undo the move
        position.unmake_move(mv);
    }

    branches
}

// perft_divide_print executes `perft_divide` and prints the result
//
// @param: position - mutable reference to the position
// @param: move_generator - immutable reference to the move generator
// @param: tt - mutable reference to the transposition table
// @param: depth - depth to calculate the perft for
// @return: number of leaf nodes at the given depth
pub fn perft_divide_print<MoveGeneratorT, PositionT>(
    position: &mut PositionT,
    move_generator: &MoveGeneratorT,
    tt: &mut impl TranspositionTable<PerftData>,
    depth: Depth,
) -> NodeCount
where
    MoveGeneratorT: MoveGenerator,
    PositionT: PositionState + PositionAttacks + PositionMoves,
{
    let entries = perft_divide(position, move_generator, tt, depth);

    let mut total = 0;
    for (mv, nodes) in entries {
        println!("{}: {}", mv, nodes);
        total += nodes;
    }

    println!("Total: {total}");
    total
}
