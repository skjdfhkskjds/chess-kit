use crate::attack_table::DefaultAttackTable;
use crate::primitives::{
    BITBOARD_FILES, BITBOARD_RANKS, BITBOARD_SQUARES, Bitboard, BitboardVec, File, Rank, Square,
};

// Direction is an enum that represents the movement direction of a sliding
// piece.
pub enum Direction {
    Up,
    Right,
    Down,
    Left,
    UpLeft,
    UpRight,
    DownRight,
    DownLeft,
}

impl DefaultAttackTable {
    // rook_mask returns the rook mask for the given square
    //
    // @param: square - square to get the mask for
    // @return: masking bitboard for the given square
    pub(crate) fn rook_mask(square: Square) -> Bitboard {
        let rook_at = BITBOARD_SQUARES[square.idx()];
        let edges = DefaultAttackTable::get_edges(square);
        let line_of_sight =
            BITBOARD_FILES[square.file().idx()] | BITBOARD_RANKS[square.rank().idx()];

        line_of_sight & !edges & !rook_at
    }

    // bishop_mask returns the bishop mask for the given square
    //
    // @param: square - square to get the mask for
    // @return: masking bitboard for the given square
    pub(crate) fn bishop_mask(square: Square) -> Bitboard {
        let bitboard = Bitboard::empty();
        let bishop_at = BITBOARD_SQUARES[square.idx()];
        let edges = DefaultAttackTable::get_edges(square);
        let line_of_sight = DefaultAttackTable::attack_ray(&bitboard, square, Direction::UpLeft)
            | DefaultAttackTable::attack_ray(&bitboard, square, Direction::UpRight)
            | DefaultAttackTable::attack_ray(&bitboard, square, Direction::DownRight)
            | DefaultAttackTable::attack_ray(&bitboard, square, Direction::DownLeft);

        line_of_sight & !edges & !bishop_at
    }

    // rook_attack_boards returns the attack boards for the given square and
    // blockers.
    //
    // @param: square - square to get the attack boards for
    // @param: blockers - blockers to use to generate the attack boards
    // @return: attack boards for the given square and blockers
    pub(crate) fn rook_attack_boards(square: Square, blockers: &[Bitboard]) -> BitboardVec {
        let mut attacks: BitboardVec = Vec::new();

        for bitboard in blockers.iter() {
            let attacking = DefaultAttackTable::attack_ray(bitboard, square, Direction::Up)
                | DefaultAttackTable::attack_ray(bitboard, square, Direction::Right)
                | DefaultAttackTable::attack_ray(bitboard, square, Direction::Down)
                | DefaultAttackTable::attack_ray(bitboard, square, Direction::Left);
            attacks.push(attacking);
        }

        attacks
    }

    // bishop_attack_boards returns the attack boards for the given square and
    // blockers.
    //
    // @param: square - square to get the attack boards for
    // @param: blockers - blockers to use to generate the attack boards
    // @return: attack boards for the given square and blockers
    pub(crate) fn bishop_attack_boards(square: Square, blockers: &[Bitboard]) -> BitboardVec {
        let mut attacks: BitboardVec = Vec::new();

        for bitboard in blockers.iter() {
            let attacking = DefaultAttackTable::attack_ray(bitboard, square, Direction::UpLeft)
                | DefaultAttackTable::attack_ray(bitboard, square, Direction::UpRight)
                | DefaultAttackTable::attack_ray(bitboard, square, Direction::DownRight)
                | DefaultAttackTable::attack_ray(bitboard, square, Direction::DownLeft);
            attacks.push(attacking);
        }

        attacks
    }

    // blocker_boards() takes a piece mask. This is a bitboard in which all
    // the bits are set for a square where a slider can move to, without
    // the edges. (As generated by the functions in the mask.rs file.)
    // blocker_boards() generates all possible permutations for the given
    // mask, using the Carry Rippler method. See the given link, or
    // http://rustic-chess.org for more information.
    // TODO: revisit this function later
    pub(crate) fn blocker_boards(mask: Bitboard) -> BitboardVec {
        let mut bb_blocker_boards: BitboardVec = Vec::new();
        let mut n: Bitboard = Bitboard::empty();

        // Carry-Rippler
        // https://www.chessprogramming.org/Traversing_Subsets_of_a_Set
        loop {
            bb_blocker_boards.push(n);
            n = n.wrapping_sub(mask) & mask;
            if n.is_empty() {
                break;
            }
        }

        bb_blocker_boards
    }

    // get_edges generates a bitboard of all the edges of the board excluding
    // the given square.
    //
    // @param: exclude - square to exclude from the edges
    // @return: bitboard of all the edges of the board
    // TODO: think about moving this function elsewhere
    fn get_edges(exclude: Square) -> Bitboard {
        let exclude_file = BITBOARD_FILES[exclude.file().idx()];
        let exclude_rank = BITBOARD_RANKS[exclude.rank().idx()];

        (BITBOARD_FILES[File::A.idx()] & !exclude_file)
            | (BITBOARD_FILES[File::H.idx()] & !exclude_file)
            | (BITBOARD_RANKS[Rank::R1.idx()] & !exclude_rank)
            | (BITBOARD_RANKS[Rank::R8.idx()] & !exclude_rank)
    }

    // attack_ray returns the attack ray from the current square in the given
    // direction based on the given bitboard.
    //
    // note: we unwrap the bitboards to u64 as a hack to enable const bitwise
    //       operations
    // 
    // @param: bitboard - bitboard to use as the base for the attack ray
    // @param: square - square to start the attack ray from
    // @param: direction - direction to attack in
    // @return: attack ray bitboard
    pub const fn attack_ray(bitboard: &Bitboard, square: Square, direction: Direction) -> Bitboard {
        // get the file and rank and the square to analyze
        let mut file = square.file();
        let mut rank = square.rank();
        let mut square = BITBOARD_SQUARES[square.idx()].const_unwrap();

        // build the ray bitboard in the given direction
        let mut ray = 0u64;
        let occupancy = bitboard.const_unwrap();
        loop {
            match direction {
                Direction::Up => {
                    if rank.const_eq(Rank::R8) {
                        break;
                    }

                    square <<= 8u8;
                    ray |= square;
                    rank.inc();
                }
                Direction::Right => {
                    if file.const_eq(File::H) {
                        break;
                    }

                    square <<= 1u8;
                    ray |= square;
                    file.inc();
                }
                Direction::Down => {
                    if rank.const_eq(Rank::R1) {
                        break;
                    }

                    square >>= 8u8;
                    ray |= square;
                    rank.dec();
                }
                Direction::Left => {
                    if file.const_eq(File::A) {
                        break;
                    }

                    square >>= 1u8;
                    ray |= square;
                    file.dec();
                }
                Direction::UpLeft => {
                    if rank.const_eq(Rank::R8) || file.const_eq(File::A) {
                        break;
                    }

                    square <<= 7u8;
                    ray |= square;
                    rank.inc();
                    file.dec();
                }
                Direction::UpRight => {
                    if rank.const_eq(Rank::R8) || file.const_eq(File::H) {
                        break;
                    }

                    square <<= 9u8;
                    ray |= square;
                    rank.inc();
                    file.inc();
                }
                Direction::DownRight => {
                    if rank.const_eq(Rank::R1) || file.const_eq(File::H) {
                        break;
                    }

                    square >>= 7u8;
                    ray |= square;
                    rank.dec();
                    file.inc();
                }
                Direction::DownLeft => {
                    if rank.const_eq(Rank::R1) || file.const_eq(File::A) {
                        break;
                    }

                    square >>= 9u8;
                    ray |= square;
                    rank.dec();
                    file.dec();
                }
            };

            // if the square is blocked, we have built the full ray in this
            // direction, so we can stop
            if square & occupancy != 0 {
                break;
            }
        }

        Bitboard::new(ray)
    }
}
